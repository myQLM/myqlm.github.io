<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quantum application (including Ansätze and state preparation) &mdash; myQLM documentation  documentation</title>
      <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css" type="text/css" />
    <link rel="shortcut icon" href="../static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../static/documentation_options.js"></script>
        <script src="../static/jquery.js"></script>
        <script src="../static/underscore.js"></script>
        <script src="../static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../static/doctools.js"></script>
        <script src="../static/sphinx_highlight.js"></script>
        <script src="../static/design-tabs.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Plugins" href="03_plugins.html" />
    <link rel="prev" title="Creating and manipulating Hamiltonians" href="01_hamiltonians.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> myQLM documentation
            <img src="../static/myqlm-doc-logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.10.5
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../01_getting_started.html">Getting started</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../02_user_guide.html">User guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../02_user_guide/01_write.html">Writing quantum programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02_user_guide/02_execute.html">Executing / Simulating quantum programs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../02_user_guide.html#libraries-built-upon-qaptiva">Libraries built upon Qaptiva</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../fermion.html">Spin and fermionic systems</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="01_hamiltonians.html">Creating and manipulating Hamiltonians</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Quantum application (including Ansätze and state preparation)</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#variational-quantum-eigensolver-vqe">Variational Quantum Eigensolver (VQE)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#quantum-chemistry-tools-for-vqe">Quantum Chemistry tools for VQE</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#molecularhamiltonian">MolecularHamiltonian</a></li>
<li class="toctree-l6"><a class="reference internal" href="#moleculeinfo">MoleculeInfo</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#fermionic-ansatz-circuits">Fermionic ansatz circuits</a></li>
<li class="toctree-l5"><a class="reference internal" href="#quantum-phase-estimation">Quantum phase estimation</a></li>
<li class="toctree-l5"><a class="reference internal" href="#trotterization-tools">Trotterization tools</a></li>
<li class="toctree-l5"><a class="reference internal" href="#quantum-subspace-expansion">Quantum subspace expansion</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="03_plugins.html">Plugins</a></li>
<li class="toctree-l4"><a class="reference internal" href="04_migrating.html">Migrating code based on deprecated library qat.dqs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../fermion.html#demos">Demos</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../combinatorial_optim_applic.html">Combinatorial optimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../%3Amyqlm%3Ainteroperability.html">Interoperability with gate-based framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../interoperability_annealing.html">Interoperability with annealing framework</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../04_api_reference.html">API reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../05_demos.html">Demos</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../%3Amyqlm%3A06_support.html">Contributing to myQLM</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../07_release_notes.html">Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">myQLM documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../02_user_guide.html">User guide</a> &raquo;</li>
          <li><a href="../fermion.html">Spin and fermionic systems</a> &raquo;</li>
      <li>Quantum application (including Ansätze and state preparation)</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="quantum-application-including-ansatze-and-state-preparation">
<h1>Quantum application (including Ansätze and state preparation)<a class="headerlink" href="#quantum-application-including-ansatze-and-state-preparation" title="Permalink to this heading"></a></h1>
<p>This page explains how to create quantum application using the <a class="reference internal" href="../04_api_reference/module_qat/module_fermion.html#module-qat.fermion" title="qat.fermion"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.fermion</span></code></a> module.</p>
<div class="contents local topic" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#variational-quantum-eigensolver-vqe" id="id1">Variational Quantum Eigensolver (VQE)</a></p></li>
<li><p><a class="reference internal" href="#quantum-chemistry-tools-for-vqe" id="id2">Quantum Chemistry tools for VQE</a></p>
<ul>
<li><p><a class="reference internal" href="#molecularhamiltonian" id="id3">MolecularHamiltonian</a></p></li>
<li><p><a class="reference internal" href="#moleculeinfo" id="id4">MoleculeInfo</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#fermionic-ansatz-circuits" id="id5">Fermionic ansatz circuits</a></p></li>
<li><p><a class="reference internal" href="#quantum-phase-estimation" id="id6">Quantum phase estimation</a></p></li>
<li><p><a class="reference internal" href="#trotterization-tools" id="id7">Trotterization tools</a></p></li>
<li><p><a class="reference internal" href="#quantum-subspace-expansion" id="id8">Quantum subspace expansion</a></p></li>
</ul>
</div>
<section id="variational-quantum-eigensolver-vqe">
<span id="qat-fermion-vqe"></span><h2>Variational Quantum Eigensolver (VQE)<a class="headerlink" href="#variational-quantum-eigensolver-vqe" title="Permalink to this heading"></a></h2>
<p>The VQE is one of the flagship algorithms using near-term quantum computers. We present in this section how to do a simple VQE using
<a class="reference internal" href="../04_api_reference/module_qat/module_fermion.html#module-qat.fermion" title="qat.fermion"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.fermion</span></code></a>.</p>
<p>We will define manually a Hubbard Hamiltonian, using one- and two-body integrals, and use them to initialize an
<a class="reference internal" href="../04_api_reference/module_qat/module_fermion/electronicstructurehamiltonian.html#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElectronicStructureHamiltonian</span></code></a>. We will then convert this Hamiltonian to its spin representation,
and find its ground state energy via VQE. To do so, we will manually create a parametric circuit (ansatz), whose parameters we will optimize.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following section explains how to define the Hubbard model manually. Nevertheless,
function <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/make_hubbard_model.html#qat.fermion.hamiltonians.make_hubbard_model" title="qat.fermion.hamiltonians.make_hubbard_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_hubbard_model()</span></code></a> is designed to create
this kind of Hamiltonian</p>
</div>
<p>Let us define the Hubbard model:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qat.fermion</span> <span class="kn">import</span> <span class="n">ElectronicStructureHamiltonian</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">H</span><span class="p">,</span> <span class="n">RX</span><span class="p">,</span> <span class="n">RY</span><span class="p">,</span> <span class="n">CNOT</span><span class="p">,</span> <span class="n">Program</span>
<span class="kn">from</span> <span class="nn">qat.qpus</span> <span class="kn">import</span> <span class="n">get_default_qpu</span>
<span class="kn">from</span> <span class="nn">qat.plugins</span> <span class="kn">import</span> <span class="n">ScipyMinimizePlugin</span>

<span class="n">nqbits</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">u</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="n">hpq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nqbits</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">hpq</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">hpq</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u</span><span class="o">/</span><span class="mi">2</span>
<span class="n">hpqrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nqbits</span><span class="p">,</span> <span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">hpqrs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hpqrs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u</span>

<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">ElectronicStructureHamiltonian</span><span class="p">(</span><span class="n">hpq</span><span class="o">=</span><span class="n">hpq</span><span class="p">,</span> <span class="n">hpqrs</span><span class="o">=</span><span class="n">hpqrs</span><span class="p">)</span>
</pre></div>
</div>
<p>We then convert the fermionic Hamiltonian to a spin Hamiltonian.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonian_sp</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="o">.</span><span class="n">to_spin</span><span class="p">()</span>
</pre></div>
</div>
<p>We compute the eigenenergies of the Hamiltonian matrix to find the exact energy.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">exact_energy</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">hamiltonian_sp</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exact_energy = </span><span class="si">{</span><span class="n">exact_energy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">Exact_energy = -1.0</span>
</pre></div>
</div>
<p>Let us write the ansatz we will optimize:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialize a Program and the number of qubits</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">qbits</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="n">nqbits</span><span class="p">)</span>

<span class="c1"># Initialize the parameters</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">new_var</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">theta&quot;</span><span class="p">)</span>
<span class="n">phi</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">new_var</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">phi&quot;</span><span class="p">)</span>

<span class="c1"># Write the ansatz</span>
<span class="n">H</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">RY</span><span class="p">(</span><span class="n">theta</span><span class="p">)(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">qbits</span><span class="p">)</span>
<span class="n">RX</span><span class="p">(</span><span class="n">phi</span><span class="p">)(</span><span class="n">qbits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Finally, we optimize the parameters such that they minimize the expectation value of the Hamiltonian we defined previously.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Choose the QPU and define the VQE stack</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span>
<span class="n">stack</span> <span class="o">=</span> <span class="n">ScipyMinimizePlugin</span><span class="p">(</span><span class="n">x0</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.23</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;COBYLA&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">qpu</span>

<span class="c1"># Submit the job to the stack</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">prog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span><span class="o">.</span><span class="n">to_job</span><span class="p">(</span><span class="n">observable</span><span class="o">=</span><span class="n">hamiltonian_sp</span><span class="p">))</span>
</pre></div>
</div>
<p>We find <span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(\phi\)</span>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;=== VQE COBYLA RESULTS ===</span><span class="se">\n</span><span class="s2">Energy = </span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="se">\n</span><span class="s2">theta, phi = </span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">=== VQE COBYLA RESULTS ===</span>
<span class="go">Energy = -0.9999999974320526</span>
<span class="go">theta, phi = [3.1416940034276815, 1.2147911128415545]</span>
</pre></div>
</div>
<p>We show in more details a VQE for fermions in our Jupyter notebooks</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All our fermionic Ansätze are located in <a class="reference internal" href="../04_api_reference/module_qat/module_fermion.html#module-qat.fermion.circuits" title="qat.fermion.circuits"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.fermion.circuits</span></code></a> module</p>
</div>
</section>
<section id="quantum-chemistry-tools-for-vqe">
<span id="qat-fermion-tools-for-vqe"></span><h2>Quantum Chemistry tools for VQE<a class="headerlink" href="#quantum-chemistry-tools-for-vqe" title="Permalink to this heading"></a></h2>
<p>Various methods are available to quantum chemists for the study of atomic and molecular systems:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Unitary coupled-cluster</strong> (UCC) ansatz construction,</p></li>
<li><p><strong>Cluster operator generation</strong>,</p></li>
<li><p><strong>Initial parameters guess via Møller-Plesset perturbation theory</strong>,</p></li>
<li><p><strong>Trotterization</strong>,</p></li>
<li><p><strong>Active space selection</strong>.</p></li>
</ul>
</div></blockquote>
<p>More information is available in the following notebooks:</p>
<blockquote>
<div><ul class="simple">
<li><p><a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fdigital_quantum_simulations_spin_fermion%2Fqat_fermion_vqe_ucc_example_1_h2.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">the resolution of a UCC ansatz using the VQE algorithm</a> for a <span class="math notranslate nohighlight">\(H_2\)</span> molecule,</p></li>
<li><p><a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fdigital_quantum_simulations_spin_fermion%2Fqat_fermion_vqe_ucc_example_2_lih.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">and a similar resolution</a> for a <span class="math notranslate nohighlight">\(LiH\)</span> molecule, with active space selection.</p></li>
</ul>
</div></blockquote>
<p>We have introduced in <a class="reference internal" href="../04_api_reference/module_qat/module_fermion.html#module-qat.fermion" title="qat.fermion"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.fermion</span></code></a> the classes <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/molecularhamiltonian.html#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a> and
<a class="reference internal" href="../04_api_reference/module_qat/module_fermion/moleculeinfo.html#qat.fermion.chemistry.wrapper.MoleculeInfo" title="qat.fermion.chemistry.wrapper.MoleculeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">MoleculeInfo</span></code></a>. These classes are helper classes, meaning they are an interface to lower-level functions
in <a class="reference internal" href="../04_api_reference/module_qat/module_fermion.html#module-qat.fermion" title="qat.fermion"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.fermion</span></code></a>, meant to simplify the way you interact with the code. We will see here how to use these classes to study a <span class="math notranslate nohighlight">\(LiH\)</span> molecule. A more thorough study is available in <a class="reference internal" href="../04_api_reference/module_qat/module_fermion.html#module-qat.fermion" title="qat.fermion"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.fermion</span></code></a>
Jupyter notebooks.</p>
<p>We will assume you already have enough information about the molecule itself. You are free to use whatever quantum chemistry library
you prefer. For simplicity’s sake, we provide a basic function based on <a class="reference external" href="https://pyscf.org/">the package PySCF</a> <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/perform_pyscf_computation.html#qat.fermion.chemistry.pyscf_tools.perform_pyscf_computation" title="qat.fermion.chemistry.pyscf_tools.perform_pyscf_computation"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_pyscf_computation()</span></code></a>
which collects the information we need.</p>
<p>We start by inputting the geometry, the basis, the spin and the charge of the molecule.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.fermion.chemistry.pyscf_tools</span> <span class="kn">import</span> <span class="n">perform_pyscf_computation</span>

<span class="n">geometry</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;Li&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)),</span> <span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.75</span><span class="p">))]</span>
<span class="n">basis</span> <span class="o">=</span> <span class="s2">&quot;6-31g&quot;</span>
<span class="n">spin</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">charge</span> <span class="o">=</span> <span class="mi">0</span>

<span class="p">(</span>
   <span class="n">rdm1</span><span class="p">,</span>
   <span class="n">orbital_energies</span><span class="p">,</span>
   <span class="n">nuclear_repulsion</span><span class="p">,</span>
   <span class="n">n_electrons</span><span class="p">,</span>
   <span class="n">one_body_integrals</span><span class="p">,</span>
   <span class="n">two_body_integrals</span><span class="p">,</span>
   <span class="n">info</span><span class="p">,</span>
<span class="p">)</span> <span class="o">=</span> <span class="n">perform_pyscf_computation</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="n">spin</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="n">charge</span><span class="p">)</span>
</pre></div>
</div>
<section id="molecularhamiltonian">
<h3>MolecularHamiltonian<a class="headerlink" href="#molecularhamiltonian" title="Permalink to this heading"></a></h3>
<p>From there, we can use the <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/molecularhamiltonian.html#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a> class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.fermion.chemistry</span> <span class="kn">import</span> <span class="n">MolecularHamiltonian</span>

<span class="c1"># Define the molecular hamiltonian</span>
<span class="n">mol_h</span> <span class="o">=</span> <span class="n">MolecularHamiltonian</span><span class="p">(</span><span class="n">one_body_integrals</span><span class="p">,</span> <span class="n">two_body_integrals</span><span class="p">,</span> <span class="n">nuclear_repulsion</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol_h</span><span class="p">)</span>
<span class="go"> MolecularHamiltonian(</span>
<span class="go"> - constant_coeff : 0.9071609330057144</span>
<span class="go"> - integrals shape</span>
<span class="go">    * one_body_integrals : (11, 11)</span>
<span class="go">    * two_body_integrals : (11, 11, 11, 11)</span>
<span class="go">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol_h</span><span class="o">.</span><span class="n">nqbits</span><span class="p">)</span>
<span class="go">22</span>
</pre></div>
</div>
<p>This class is different from the spin, fermion and electronic-structure Hamiltonian classes we have seen so far.
It is defined using interaction integrals. You can convert it to an
<a class="reference internal" href="../04_api_reference/module_qat/module_fermion/electronicstructurehamiltonian.html#qat.fermion.hamiltonians.ElectronicStructureHamiltonian" title="qat.fermion.hamiltonians.ElectronicStructureHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElectronicStructureHamiltonian</span></code></a> using the method
<a class="reference internal" href="../04_api_reference/module_qat/module_fermion/molecularhamiltonian.html#qat.fermion.chemistry.wrapper.MolecularHamiltonian.get_electronic_hamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian.get_electronic_hamiltonian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_electronic_hamiltonian()</span></code></a>.</p>
<p><a class="reference internal" href="../04_api_reference/module_qat/module_fermion/molecularhamiltonian.html#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a> allows:</p>
<ul class="simple">
<li><p>the change of the one and two body integrals to a new basis, using <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/molecularhamiltonian.html#qat.fermion.chemistry.wrapper.MolecularHamiltonian.transform_basis" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian.transform_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_basis()</span></code></a></p></li>
<li><p>the selection of the active space, using <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/molecularhamiltonian.html#qat.fermion.chemistry.wrapper.MolecularHamiltonian.select_active_space" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian.select_active_space"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_active_space()</span></code></a></p></li>
</ul>
<p>To illustrate this, we will compute the natural orbitals occupation numbers (NOONs) as well as their basis transformation matrix.
We will then use the <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/molecularhamiltonian.html#qat.fermion.chemistry.wrapper.MolecularHamiltonian.transform_basis" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian.transform_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_basis()</span></code></a> method to change the basis of our
<a class="reference internal" href="../04_api_reference/module_qat/module_fermion/molecularhamiltonian.html#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Compute NOONs and the basis</span>
<span class="n">noons</span><span class="p">,</span> <span class="n">basis_change</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">rdm1</span><span class="p">)</span>

<span class="c1"># The noons should be in decreasing order. This means we should flip the basis as well.</span>
<span class="n">noons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">noons</span><span class="p">))</span>
<span class="n">basis_change</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">basis_change</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Change the hamiltonian basis</span>
<span class="n">mol_h_new_basis</span> <span class="o">=</span> <span class="n">mol_h</span><span class="o">.</span><span class="n">transform_basis</span><span class="p">(</span><span class="n">basis_change</span><span class="p">)</span>
</pre></div>
</div>
<p>We can then proceed to the active space selection.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Active space selection</span>
<span class="n">mol_h_active</span><span class="p">,</span> <span class="n">active_indices</span><span class="p">,</span> <span class="n">occupied_indices</span> <span class="o">=</span> <span class="n">mol_h_new_basis</span><span class="o">.</span><span class="n">select_active_space</span><span class="p">(</span>
   <span class="n">noons</span><span class="o">=</span><span class="n">noons</span><span class="p">,</span> <span class="n">n_electrons</span><span class="o">=</span><span class="n">n_electrons</span><span class="p">,</span> <span class="n">threshold_1</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">threshold_2</span><span class="o">=</span><span class="mf">0.002</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol_h_active</span><span class="p">)</span>
<span class="go"> MolecularHamiltonian(</span>
<span class="go"> - constant_coeff : 0.9071609330057144</span>
<span class="go"> - integrals shape</span>
<span class="go">    * one_body_integrals : (2, 2)</span>
<span class="go">    * two_body_integrals : (2, 2, 2, 2)</span>
<span class="go">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol_h_active</span><span class="o">.</span><span class="n">nqbits</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
<p>We reduced the number of qubits from 22 to 4 qubits !</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>You can access the one and two body integrals, and the constant (nuclear repulsion) via the attributes <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/molecularhamiltonian.html#qat.fermion.chemistry.wrapper.MolecularHamiltonian.one_body_integrals" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian.one_body_integrals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">one_body_integrals</span></code></a>, <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/molecularhamiltonian.html#qat.fermion.chemistry.wrapper.MolecularHamiltonian.two_body_integrals" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian.two_body_integrals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">two_body_integrals</span></code></a> and <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/molecularhamiltonian.html#qat.fermion.chemistry.wrapper.MolecularHamiltonian.constant_coeff" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian.constant_coeff"><code class="xref py py-attr docutils literal notranslate"><span class="pre">constant_coeff</span></code></a>.</p></li>
<li><p>The number of qubits is accessible via <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/molecularhamiltonian.html#qat.fermion.chemistry.wrapper.MolecularHamiltonian.nqbits" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian.nqbits"><code class="xref py py-attr docutils literal notranslate"><span class="pre">nqbits</span></code></a>.</p></li>
</ul>
</div>
</section>
<section id="moleculeinfo">
<h3>MoleculeInfo<a class="headerlink" href="#moleculeinfo" title="Permalink to this heading"></a></h3>
<p>While the <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/molecularhamiltonian.html#qat.fermion.chemistry.wrapper.MolecularHamiltonian" title="qat.fermion.chemistry.wrapper.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a> brings simplicity, we can add another layer of simplicity by
using the <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/moleculeinfo.html#qat.fermion.chemistry.wrapper.MoleculeInfo" title="qat.fermion.chemistry.wrapper.MoleculeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">MoleculeInfo</span></code></a> class. When restricting the active space,
<a class="reference internal" href="../04_api_reference/module_qat/module_fermion/moleculeinfo.html#qat.fermion.chemistry.wrapper.MoleculeInfo" title="qat.fermion.chemistry.wrapper.MoleculeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">MoleculeInfo</span></code></a> takes care of updating its attributes such as the active and occupied orbitals
indices, as well as the direct update of the NOONs and orbital energies.</p>
<p>The <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/moleculeinfo.html#qat.fermion.chemistry.wrapper.MoleculeInfo" title="qat.fermion.chemistry.wrapper.MoleculeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">MoleculeInfo</span></code></a> class is used in <a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fdigital_quantum_simulations_spin_fermion%2Fqat_fermion_vqe_ucc_example_2_lih.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">our VQE UCC ansatz resolution</a> of the <span class="math notranslate nohighlight">\(LiH\)</span> molecule.</p>
</section>
</section>
<section id="fermionic-ansatz-circuits">
<span id="qat-fermion-ansatz"></span><h2>Fermionic ansatz circuits<a class="headerlink" href="#fermionic-ansatz-circuits" title="Permalink to this heading"></a></h2>
<p>We also provide some circuits useful in a context of VQE on fermionic systems:</p>
<ul class="simple">
<li><p><strong>Low-Depth Circuit Ansatz (LDCA):</strong> a general ansatz for correlated fermionic systems - using <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/make_ldca_circ.html#qat.fermion.circuits.make_ldca_circ" title="qat.fermion.circuits.make_ldca_circ"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_ldca_circ()</span></code></a></p></li>
<li><p><strong>Multi-Reference (MR) ansatz:</strong> a four-qubit, one-parameter ansatz - using <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/make_mr_circ.html#qat.fermion.circuits.make_mr_circ" title="qat.fermion.circuits.make_mr_circ"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_mr_circ()</span></code></a></p></li>
<li><p><strong>Multi-Reference, Excitation-Preserving (MREP) ansatz:</strong> a eight-qubit ansatz building on the MR ansatz - using <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/make_mrep_circ.html#qat.fermion.circuits.make_mrep_circ" title="qat.fermion.circuits.make_mrep_circ"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_mrep_circ()</span></code></a></p></li>
<li><p>The 8-parameter circuit ansatz - using <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/make_shallow_circ.html#qat.fermion.circuits.make_shallow_circ" title="qat.fermion.circuits.make_shallow_circ"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_shallow_circ()</span></code></a></p></li>
<li><p><strong>General hardware-efficient ansatz:</strong> a general constructor - using <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/make_general_hwe_circ.html#qat.fermion.circuits.make_general_hwe_circ" title="qat.fermion.circuits.make_general_hwe_circ"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_general_hwe_circ()</span></code></a></p></li>
<li><p><strong>(Only for Qaptiva users) Compressed LDCA ansatz:</strong> the compressed version of the LDCA ansatz circuit - using <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/make_compressed_ldca_circ.html#qat.fermion.circuits.make_compressed_ldca_circ" title="qat.fermion.circuits.make_compressed_ldca_circ"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_compressed_ldca_circ()</span></code></a></p></li>
</ul>
</section>
<section id="quantum-phase-estimation">
<span id="qat-fermion-phase-estimation"></span><h2>Quantum phase estimation<a class="headerlink" href="#quantum-phase-estimation" title="Permalink to this heading"></a></h2>
<p>The quantum phase space estimation algorithm allows for the estimation of the eigenvalue associated
with a given eigenvector. Let us see how to use this algorithm with a simple example.</p>
<p>We will first define a Hubbard model, and find its exact eigenenergies via direct diagonalization.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qat.fermion.hamiltonians</span> <span class="kn">import</span> <span class="n">make_hubbard_model</span>

<span class="c1"># Define the Hubbard model</span>
<span class="n">U</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">t</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">t_mat</span> <span class="o">=</span> <span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>

<span class="c1"># We get an ElectronicStructureHamiltonian</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">make_hubbard_model</span><span class="p">(</span><span class="n">t_mat</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">U</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># Find its eigenenergies</span>
<span class="n">eigvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">eigvals</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>

<span class="c1"># Now we know the exact eigenenergies, let us find them once again using the quantum phase estimation algorithm.</span>

<span class="kn">from</span> <span class="nn">qat.qpus</span> <span class="kn">import</span> <span class="n">get_default_qpu</span>
<span class="kn">from</span> <span class="nn">qat.fermion.phase_estimation</span> <span class="kn">import</span> <span class="n">perform_phase_estimation</span>

<span class="n">qpu</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span>

<span class="n">nqbits_phase</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">n_trotter_steps</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">guess_energy</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.1</span>  <span class="c1"># try an energy which is off from 0</span>
<span class="n">size_interval</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">energy</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">perform_phase_estimation</span><span class="p">(</span>
    <span class="n">hamiltonian</span><span class="p">,</span>
    <span class="n">nqbits_phase</span><span class="p">,</span>
    <span class="n">n_trotter_steps</span><span class="p">,</span>
    <span class="n">E_target</span><span class="o">=</span><span class="n">guess_energy</span><span class="p">,</span>
    <span class="n">size_interval</span><span class="o">=</span><span class="n">size_interval</span><span class="p">,</span>
    <span class="n">qpu</span><span class="o">=</span><span class="n">qpu</span><span class="p">,</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;E = </span><span class="si">{</span><span class="n">energy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">-</span><span class="mf">1.1403</span> <span class="o">-</span><span class="mf">1.</span>     <span class="o">-</span><span class="mf">1.</span>     <span class="o">-</span><span class="mf">1.</span>     <span class="o">-</span><span class="mf">0.7</span>    <span class="o">-</span><span class="mf">0.7</span>    <span class="o">-</span><span class="mf">0.7</span>    <span class="o">-</span><span class="mf">0.7</span>    <span class="o">-</span><span class="mf">0.3</span>
 <span class="o">-</span><span class="mf">0.3</span>    <span class="o">-</span><span class="mf">0.3</span>    <span class="o">-</span><span class="mf">0.3</span>     <span class="mf">0.</span>      <span class="mf">0.</span>      <span class="mf">0.</span>      <span class="mf">0.1403</span><span class="p">]</span>
<span class="n">E</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.002343750000000089</span>
</pre></div>
</div>
<p>We find an energy very close to some of the exact eigenenergies we computed earlier !</p>
<p>More information is available in the <a class="reference internal" href="../04_api_reference/module_qat/module_fermion.html#qat-fermion-source-qpe"><span class="std std-ref">source code documentation</span></a> and in the notebook <a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fdigital_quantum_simulations_spin_fermion%2Fqat_fermion_qpe_hubbard_molecule.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">on quantum phase estimation on the Hubbard molecule</a>.</p>
</section>
<section id="trotterization-tools">
<span id="qat-fermion-trotter"></span><h2>Trotterization tools<a class="headerlink" href="#trotterization-tools" title="Permalink to this heading"></a></h2>
<p>You can trotterize any Hamiltonian using our trotterization tools.</p>
<p>Here is an example.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span>
<span class="kn">from</span> <span class="nn">qat.fermion.trotterisation</span> <span class="kn">import</span> <span class="n">make_trotterisation_routine</span>
<span class="kn">from</span> <span class="nn">qat.fermion.hamiltonians</span> <span class="kn">import</span> <span class="n">make_hubbard_model</span>

<span class="c1"># Define the Hubbard model</span>
<span class="n">U</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">t</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">t_mat</span> <span class="o">=</span> <span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>

<span class="c1"># We get an ElectronicStructureHamiltonian</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">make_hubbard_model</span><span class="p">(</span><span class="n">t_mat</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">U</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># Trotterize the Hamiltonian (with 1 trotter step)</span>
<span class="n">qrout</span> <span class="o">=</span> <span class="n">make_trotterisation_routine</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">,</span> <span class="n">n_trotter_steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">final_time</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Define an empty Program and apply the QRoutine on it</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">reg</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">nbqbits</span><span class="p">)</span>
<span class="n">prog</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">qrout</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">circ</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../images/qat-fermion_trotter.png"><img alt="../images/qat-fermion_trotter.png" src="../images/qat-fermion_trotter.png" style="width: 800px;" /></a>
<p>For more information, see the <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/make_trotterisation_routine.html#qat.fermion.trotterisation.make_trotterisation_routine" title="qat.fermion.trotterisation.make_trotterisation_routine"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_trotterisation_routine()</span></code></a> function documentation.
The trotterization is used for the UCC ansatz construction in our UCC VQE notebooks,
see <a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fdigital_quantum_simulations_spin_fermion%2Fqat_fermion_vqe_ucc_example_1_h2.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">here</a> for the <span class="math notranslate nohighlight">\(H_2\)</span> molecule, and <a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fdigital_quantum_simulations_spin_fermion%2Fqat_fermion_vqe_ucc_example_2_lih.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">here</a> for the <span class="math notranslate nohighlight">\(LiH\)</span> molecule.</p>
</section>
<section id="quantum-subspace-expansion">
<span id="qat-fermion-qse"></span><h2>Quantum subspace expansion<a class="headerlink" href="#quantum-subspace-expansion" title="Permalink to this heading"></a></h2>
<p>The quantum subspace expansion is a method that can allow to reach a better precision at the cost of doing additional measurements.
You will find more details directly in the <a class="reference internal" href="../04_api_reference/module_qat/module_fermion/apply_quantum_subspace_expansion.html#qat.fermion.chemistry.qse.apply_quantum_subspace_expansion" title="qat.fermion.chemistry.qse.apply_quantum_subspace_expansion"><code class="xref py py-func docutils literal notranslate"><span class="pre">apply_quantum_subspace_expansion()</span></code></a> documentation.
See how to use it in <a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fdigital_quantum_simulations_spin_fermion%2Fqat_fermion_quantum_subspace_expansion_h2.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">the quantum subspace expansion notebook</a>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="01_hamiltonians.html" class="btn btn-neutral float-left" title="Creating and manipulating Hamiltonians" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="03_plugins.html" class="btn btn-neutral float-right" title="Plugins" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Eviden 2016-2024.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>