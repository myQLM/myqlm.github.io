

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qat.synthopline.generate_trotter_ansatz &mdash; myQLM documentation  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../static/css/custom.css?v=bee1f38e" />
      <link rel="stylesheet" type="text/css" href="../../../static/sphinx-design.min.css?v=95c83b7e" />

  
    <link rel="shortcut icon" href="../../../static/favicon.png"/>
      <script src="../../../static/jquery.js?v=5d32c60e"></script>
      <script src="../../../static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../static/documentation_options.js?v=8a448e45"></script>
      <script src="../../../static/doctools.js?v=9bcbadda"></script>
      <script src="../../../static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="qat.synthopline.linear_operator_synthesis" href="linear_operator_synthesis.html" />
    <link rel="prev" title="qat.synthopline.clifford_normalizer.CliffordNormalizer" href="cliffordnormalizer.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            myQLM documentation
              <img src="../../../static/myqlm-doc-logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../01_getting_started.html">Getting started</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../02_user_guide.html">User guide</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../../04_api_reference.html">API reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../module_qat.html">qat</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../module_comm.html">qat.comm</a></li>
<li class="toctree-l3"><a class="reference internal" href="../module_core.html">qat.core</a></li>
<li class="toctree-l3"><a class="reference internal" href="../module_devices.html">qat.devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../module_fermion.html">qat.fermion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../module_fusion.html">qat.fusion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../module_generators.html">qat.generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../module_hardware.html">qat.hardware</a></li>
<li class="toctree-l3"><a class="reference internal" href="../%3Amyqlm%3Amodule_interop.html">qat.interop</a></li>
<li class="toctree-l3"><a class="reference internal" href="../module_lang.html">qat.lang</a></li>
<li class="toctree-l3"><a class="reference internal" href="../module_nnize.html">qat.nnize</a></li>
<li class="toctree-l3"><a class="reference internal" href="../module_opt.html">qat.opt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../module_pbo.html">qat.pbo</a></li>
<li class="toctree-l3"><a class="reference internal" href="../module_plugins.html">qat.plugins</a></li>
<li class="toctree-l3"><a class="reference internal" href="../%3Amyqlm%3Amodule_pylinalg.html">qat.pylinalg</a></li>
<li class="toctree-l3"><a class="reference internal" href="../module_qpus.html">qat.qpus</a></li>
<li class="toctree-l3"><a class="reference internal" href="../module_quops.html">qat.quops</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../module_synthopline.html">qat.synthopline</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="cliffordnormalizer.html">qat.synthopline.clifford_normalizer.CliffordNormalizer</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">qat.synthopline.generate_trotter_ansatz</a></li>
<li class="toctree-l4"><a class="reference internal" href="linear_operator_synthesis.html">qat.synthopline.linear_operator_synthesis</a></li>
<li class="toctree-l4"><a class="reference internal" href="phase_polynomial_synthesis.html">qat.synthopline.phase_polynomial_synthesis</a></li>
<li class="toctree-l4"><a class="reference internal" href="extract_linear_operator.html">qat.synthopline.linear_synthesis.extract_linear_operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="extract_pauli_rotations.html">qat.synthopline.util.extract_pauli_rotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="extract_phase_polynomial.html">qat.synthopline.phase_polynomials.extract_phase_polynomial</a></li>
<li class="toctree-l4"><a class="reference internal" href="generate_random_observable.html">qat.synthopline.pauli_synth.generate_random_observable</a></li>
<li class="toctree-l4"><a class="reference internal" href="random_linear_operator.html">qat.synthopline.linear_synthesis.random_linear_operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="random_phase_polynomial.html">qat.synthopline.phase_polynomials.random_phase_polynomial</a></li>
<li class="toctree-l4"><a class="reference internal" href="frequency_mapping.html">qat.synthopline.initial_mapping.frequency_mapping</a></li>
<li class="toctree-l4"><a class="reference internal" href="greedy_mapping.html">qat.synthopline.initial_mapping.greedy_mapping</a></li>
<li class="toctree-l4"><a class="reference internal" href="codiagonalize_with_architecture.html">qat.synthopline.co_diagonalization.codiagonalize_with_architecture</a></li>
<li class="toctree-l4"><a class="reference internal" href="conjugate_observable_tableau.html">qat.synthopline.util.conjugate_observable_tableau</a></li>
<li class="toctree-l4"><a class="reference internal" href="synthesize_stabilizer_state.html">qat.synthopline.co_diagonalization.synthesize_stabilizer_state</a></li>
<li class="toctree-l4"><a class="reference internal" href="operatortableau.html">qat.synthopline.interface.OperatorTableau</a></li>
<li class="toctree-l4"><a class="reference internal" href="weyloperator.html">qat.synthopline.interface.WeylOperator</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../05_demos.html">Demos</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../%3Amyqlm%3A06_support.html">Contributing to myQLM</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../07_release_notes.html">Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">myQLM documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../04_api_reference.html">API reference</a></li>
          <li class="breadcrumb-item"><a href="../../module_qat.html">qat</a></li>
          <li class="breadcrumb-item"><a href="../module_synthopline.html">qat.synthopline</a></li>
      <li class="breadcrumb-item active">qat.synthopline.generate_trotter_ansatz</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="qat-synthopline-generate-trotter-ansatz">
<h1>qat.synthopline.generate_trotter_ansatz<a class="headerlink" href="#qat-synthopline-generate-trotter-ansatz" title="Link to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="qat.synthopline.generate_trotter_ansatz">
<span class="sig-prename descclassname"><span class="pre">qat.synthopline.</span></span><span class="sig-name descname"><span class="pre">generate_trotter_ansatz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">operators</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsteps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_observable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'naive'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qat.synthopline.generate_trotter_ansatz" title="Link to this definition"></a></dt>
<dd><p>Builds a ready-to-use QLM job via a Trotter expansion of set of operators.</p>
<p>The function takes a collection of <a class="reference internal" href="../module_core/observable.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observable</span></code></a>. Each such operator <span class="math notranslate nohighlight">\(H\)</span>
will be expanded as a product of Pauli rotations, collectivelly parametrized by the same
variational parameter. These expansions are then concatenated in order to build one layer
of the final circuit. The number of layers can be specified by the <cite>steps</cite> parameter.</p>
<p>For instance, if the input consists in two operators <span class="math notranslate nohighlight">\(H_1 = \sum \alpha_i h^{(1)}_i\)</span>
and <span class="math notranslate nohighlight">\(H_2 = \sum \alpha_j h^{(2)}_j\)</span>, the resulting parametrized circuit will have shape:</p>
<div class="math notranslate nohighlight">
\[\prod_j exp\left( -a_2 \alpha_j h^{(2)}_j \right) \prod_i exp\left( -a_1 \alpha_i h^{(1)}_i \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(a_1,a_2\)</span> are variational parameters (i.e abstract parameters).</p>
<p>Notice that :</p>
<blockquote>
<div><ul class="simple">
<li><p>the order between the two products is the same as the order of the inputs (in term of
circuits <span class="math notranslate nohighlight">\(H_1\)</span> comes before <span class="math notranslate nohighlight">\(H_2\)</span>)</p></li>
<li><p>the terms of the two operators are collectively parametrized</p></li>
<li><p>the term ordering in each product might vary depending on the backend method</p></li>
</ul>
</div></blockquote>
<p class="rubric">Example</p>
<p>This example illustrates the role of the <cite>group</cite> parameter:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">qat.synthopline.pauli_synth</span><span class="w"> </span><span class="kn">import</span> <span class="n">generate_trotter_ansatz</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">qat.synthopline.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">extract_pauli_rotations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">qat.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">Observable</span>

<span class="n">H0</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="n">sigma_z</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">Observable</span><span class="o">.</span><span class="n">sigma_z</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>\
    <span class="o">+</span>  <span class="n">Observable</span><span class="o">.</span><span class="n">sigma_z</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">Observable</span><span class="o">.</span><span class="n">sigma_z</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;H0:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">H0</span><span class="p">)</span>
<span class="n">H1</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">Observable</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>\
    <span class="o">+</span>  <span class="n">Observable</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">Observable</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;H1:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">H1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Without grouping:&quot;</span><span class="p">)</span>
<span class="n">ansatz</span> <span class="o">=</span> <span class="n">generate_trotter_ansatz</span><span class="p">(</span><span class="n">H0</span><span class="p">,</span> <span class="n">H1</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;pauli_synth&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ansatz</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">iterate_simple</span><span class="p">()</span> <span class="k">if</span> <span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CNOT&quot;</span><span class="p">),</span> <span class="s2">&quot;CNOTs&quot;</span><span class="p">)</span>
<span class="c1"># We expect to find all terms of H0, followed by all terms of H1</span>
<span class="n">rotations</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">extract_pauli_rotations</span><span class="p">(</span><span class="n">ansatz</span><span class="o">.</span><span class="n">circuit</span><span class="p">)</span>
<span class="k">for</span> <span class="n">angle</span><span class="p">,</span> <span class="n">rotation</span> <span class="ow">in</span> <span class="n">rotations</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;With grouping:&quot;</span><span class="p">)</span>
<span class="n">ansatz</span> <span class="o">=</span> <span class="n">generate_trotter_ansatz</span><span class="p">(</span><span class="n">H0</span><span class="p">,</span> <span class="n">H1</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;pauli_synth&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ansatz</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">iterate_simple</span><span class="p">()</span> <span class="k">if</span> <span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;CNOT&quot;</span><span class="p">),</span> <span class="s2">&quot;CNOTs&quot;</span><span class="p">)</span>
<span class="c1"># We expect to find terms of H0 and H1 mixed in arbitrary order</span>
<span class="n">rotations</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">extract_pauli_rotations</span><span class="p">(</span><span class="n">ansatz</span><span class="o">.</span><span class="n">circuit</span><span class="p">)</span>
<span class="k">for</span> <span class="n">angle</span><span class="p">,</span> <span class="n">rotation</span> <span class="ow">in</span> <span class="n">rotations</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H0</span><span class="p">:</span>
 <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ZZ</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ZZ</span><span class="o">|</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">H1</span><span class="p">:</span>
 <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">XX</span><span class="o">|</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
<span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">XX</span><span class="o">|</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">Without</span> <span class="n">grouping</span><span class="p">:</span>
<span class="mi">4</span> <span class="n">CNOTs</span>
<span class="n">ZZI</span> <span class="n">t_</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="n">IZZ</span> <span class="n">t_</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="n">IXX</span> <span class="n">t_</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
<span class="n">XXI</span> <span class="n">t_</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
<span class="n">With</span> <span class="n">grouping</span><span class="p">:</span>
<span class="mi">3</span> <span class="n">CNOTs</span>
<span class="n">IXX</span> <span class="n">t_</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
<span class="n">IZZ</span> <span class="n">t_</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="n">XXI</span> <span class="n">t_</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
<span class="n">ZZI</span> <span class="n">t_</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<p>Notice how the order in which the rotation were synthesized changed. In the second case,
all rotations were synthesized in one go, which led to some optimization (we gained one CNOT).
Depending of the application, both situations can be useful.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*operators</strong> (list of <a class="reference internal" href="../module_core/observable.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observable</span></code></a>) – a collection of operators (at least one)</p></li>
<li><p><strong>nsteps</strong> (<em>optional</em><em>, </em><em>int</em>) – the number of Trotter steps to perform. Defaults to 1.</p></li>
<li><p><strong>group</strong> (<em>optional</em><em>, </em><em>bool</em>) – if set to True, the operators are (1) parametrized and then (2) summed and
considered as a single large operator to expand. This is the expected behavior for UCCSD
Ansätze, for instance. Defaults to False.</p></li>
<li><p><strong>final_observable</strong> (optional, <a class="reference internal" href="../module_core/observable.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observable</span></code></a>) – the final observable to sample.
If unset, the first operator is used as final operator.</p></li>
<li><p><strong>init_state</strong> (<em>int/str</em>) – a description of the initial state to prepare. Input can be given as a string with
characters in ‘0’, ‘1’, ‘+’, ‘-’, or as an integer, in which case it will be interpreted as a bitstring
over <span class="math notranslate nohighlight">\(n\)</span> qubits, qubit 0 being the most significant bit. Defaults to 0.</p></li>
<li><p><strong>strategy</strong> (<em>optional</em><em>, </em><em>str</em>) – the backend strategy to use to generate the circuit. See below for details.
Defaults to <strong>naive</strong>.</p></li>
<li><p><strong>kwargs</strong> – any strategy dependent argument can be passed as a kwargs.</p></li>
</ul>
</dd>
</dl>
<p>Strategies:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>naive</strong> generates a naive quantum circuit implementation. Each term of each
operator is diagonalized using local Clifford gates, then reduced using a cascade
of CNOT gates, thus using <span class="math notranslate nohighlight">\(2(k-1)\)</span> CNOT gates per rotation of weight <span class="math notranslate nohighlight">\(k\)</span>.</p></li>
<li><p><strong>pauli_synth</strong> uses a recursive strategy to optimize the rotation order as an
attempt to reduce the overall CNOT cost of the circuit.</p></li>
<li><p><strong>commute</strong> was introduce in <span id="id1">[<a class="reference internal" href="../../../02_user_guide/03_compile.html#id9" title="Alexander Cowtan, Will Simmons, and Ross Duncan. A generic compilation strategy for the unitary coupled cluster ansatz. 2020. arXiv:2007.10515.">CSD20</a>]</span>. It consists in co-diagonalizing
commuting terms of each operator, and synthesizing them using the GraySynth algorithm.</p></li>
<li><p><strong>commute_improved</strong> is a variant of <strong>commute</strong> where co-diagonalization fixes are pulled
to the end of the circuit. This can sometimes reduce the CNOT count.</p></li>
<li><p><strong>greedy</strong> greedily picks the next Pauli rotation to implement in order to reduce
the CNOT count.</p></li>
<li><p><strong>greedy_depth</strong> picks the next Pauli rotation to implement in order to reduce the
overall CNOT depth.</p></li>
</ul>
</div></blockquote>
<p>Additional arguments:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><strong>pauli_synth</strong>:</dt><dd><ul>
<li><p><strong>graph</strong> (optional, networkx.Graph): an architecture graph. If
no graph is provided, the algorithm assumes perfect connectivity.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>commute</strong>:</dt><dd><ul>
<li><p><strong>co_diag_backend</strong> (optional, int): the co-diagonalization backend to use in order to generate the Clifford
subcircuits. 0 is for Duncan et al heuristic (see reference), 1 is for naive graph state synthesis, and 2 is for
syndrome decoding based graph state synthesis. Default is 0.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>commute_improved</strong>:</dt><dd><ul>
<li><p><strong>co_diag_backend</strong> (optional, int): same as for “commute”.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Different backend methods might produce non-equivalent circuits
(up to commutation of some Pauli rotations).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Produced jobs are parametrized by variables with name <cite>t_{i}</cite>.
Indexes are skipped from one Trotter layer to the next.</p>
<p>For instance, two Trotter steps for three operators will produce a job with variable
names <cite>t_{0}</cite>, <cite>t_{1}</cite>, <cite>t_{2}</cite> for the first layer, and <cite>t_{4}</cite>, <cite>t_{5}</cite>, <cite>t_{6}</cite>
for the second layer.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is available as an application in Qaptiva Access.</p>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="cliffordnormalizer.html" class="btn btn-neutral float-left" title="qat.synthopline.clifford_normalizer.CliffordNormalizer" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="linear_operator_synthesis.html" class="btn btn-neutral float-right" title="qat.synthopline.linear_operator_synthesis" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Eviden 2016-2025.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>