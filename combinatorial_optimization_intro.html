

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Combinatorial optimization &mdash; myQLM documentation myQLM-1.1.5.20 documentation</title>
  

  
  
    <link rel="shortcut icon" href="static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
        <script src="static/jquery.js"></script>
        <script src="static/underscore.js"></script>
        <script src="static/doctools.js"></script>
        <script src="static/language_data.js"></script>
        <script src="static/contentui.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Interoperability with myQLM" href="myqlm_specific/interoperability.html" />
    <link rel="prev" title="Running variational algorithms" href="running_variational.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> myQLM documentation
          

          
            
            <img src="static/myqlm.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                myQLM-1.1.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Basic usage</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/install.html">Installing myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="programming.html">Writing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulating.html">Executing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="running_variational.html">Running variational algorithms</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Combinatorial optimization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#formulating-combinatorial-problems">Formulating combinatorial problems</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ising-hamiltonians">Ising Hamiltonians</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quadratic-unconstrained-binary-optimization-qubo">Quadratic Unconstrained Binary Optimization (QUBO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#general-combinatorial-problems">General combinatorial problems</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#solving-combinatorial-problems">Solving combinatorial problems</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quantum-approximate-optimization-algorithm-qaoa">Quantum Approximate Optimization Algorithm (QAOA)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bibliography">Bibliography</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/interoperability.html">Interoperability with myQLM</a></li>
</ul>
<p class="caption"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="manipulating.html">Building custom execution stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Architecture and data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_programming.html">Advanced programming using pyAQASM</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_combinatorial_optimization.html">Advanced combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="source_doc.html">Source code documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="aqasm.html">The AQASM format</a></li>
<li class="toctree-l1"><a class="reference internal" href="commands.html">Command line tools</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">myQLM documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Combinatorial optimization</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="combinatorial-optimization">
<span id="id1"></span><h1>Combinatorial optimization<a class="headerlink" href="#combinatorial-optimization" title="Permalink to this headline">¶</a></h1>
<p>Many real life problems are combinatorial and solving them has actual practical applications. An intrinsic feature of these problems is that they can be formulated as minimization or maximization problems, i.e. with a cost function. At the same time finding the lowest energy of a physical system, represented by a cost Hamiltonian, is also a minimization problem. Due to this intimate relation, problems described with a cost function (<a class="reference internal" href="#qubo-description"><span class="std std-ref">QUBO</span></a>) or a cost Hamiltonian (<a class="reference internal" href="#ising-description"><span class="std std-ref">Ising</span></a>) could be solved by simulating the process of finding their minimum energy. This lowest energy should encode the solution to our problem.</p>
<p>myQLM provides <a class="reference internal" href="qat-opt.html#qubo-and-ising-code"><span class="std std-ref">helper classes</span></a> for both of these formulations, and also the more generic <a class="reference internal" href="#combinatorial-problem-description"><span class="std std-ref">Combinatorial Problem</span></a>, in which one can describe problems with clauses and variables - see the <a class="reference internal" href="#formulating-comb"><span class="std std-ref">Formulating combinatorial problems</span></a> section below.</p>
<p>Once the problems are encoded, one could solve them using a Quantum Approximate Optimization Algorithm (<a class="reference internal" href="#qaoa-description"><span class="std std-ref">QAOA</span></a>). There are also tools to solve the problems via Simulated Annealing (SA) and Simulated Quantum Annealing (SQA), but they come in the full QLM version.</p>
<p>Among the many different combinatorial problems, some of the most interesting and challenging ones are the NP-hard problems. A lot of effort has been put over the last 10-15 years into formulating such optimization problems as QUBO/Ising instances. See <a class="bibtex reference internal" href="#lucas2014ising" id="id3">[Luc14]</a>  for an extensive reference. A direct encoding of some of these problems, described in the <a class="reference internal" href="advanced_combinatorial_optimization.html#np-problems-formulation"><span class="std std-ref">NP Hard problems</span></a> section, has also been <a class="reference internal" href="qat-opt.html#np-hard-problems-code"><span class="std std-ref">implemented</span></a> on myQLM.</p>
<div class="section" id="formulating-combinatorial-problems">
<span id="formulating-comb"></span><h2>Formulating combinatorial problems<a class="headerlink" href="#formulating-combinatorial-problems" title="Permalink to this headline">¶</a></h2>
<p>This section presents definitions of Ising Hamiltonians and QUBO cost functions, along with our conventions regarding their precise formulation. Here is the outline:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><a class="reference internal" href="#ising-hamiltonians">Ising Hamiltonians</a></p></li>
<li><p><a class="reference internal" href="#quadratic-unconstrained-binary-optimization-qubo">Quadratic Unconstrained Binary Optimization (QUBO)</a></p></li>
<li><p><a class="reference internal" href="#general-combinatorial-problems">General combinatorial problems</a></p></li>
</ol>
</div></blockquote>
<div class="section" id="ising-hamiltonians">
<span id="ising-description"></span><h3>Ising Hamiltonians<a class="headerlink" href="#ising-hamiltonians" title="Permalink to this headline">¶</a></h3>
<p>Given <span class="math notranslate nohighlight">\(n\)</span> qubits, a <strong>2-local Ising Hamiltonian</strong> is an operator of the
form:</p>
<div class="math notranslate nohighlight">
\[H = - \sum_{i=1}^{n} h_{i}\sigma_{z}^{i} - \sum_{i,j=1}^{n} J_{ij}\sigma_{z}^{i}\sigma_{z}^{j}\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma_{z}^{i} = \begin{pmatrix}1 &amp; 0 \\ 0 &amp; -1 \end{pmatrix}\)</span>,
<span class="math notranslate nohighlight">\(h\)</span> is a vector of real coefficients usually referred to as the <strong>local magnetic field</strong>,
and <span class="math notranslate nohighlight">\(J\)</span> is a <strong>real symmetric matrix with a zero diagonal</strong>, usually referred to as the <strong>coupling matrix</strong>.</p>
<p>This Hamiltonian is the direct <strong>quantization</strong> of the following <strong>classical Ising cost
function</strong>:</p>
<div class="math notranslate nohighlight">
\[H(s_{1},...,s_{n}) = - \sum_{i=1}^{n} h_{i}s_{i} - \sum_{i,j=1}^{n} J_{ij}s_{i}s_{j}\]</div>
<p>where <span class="math notranslate nohighlight">\(s_{i}\in \{-1,1\}\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the <strong>interaction term</strong>, we do <strong>not</strong> restrict the sum to, e.g.,
<span class="math notranslate nohighlight">\(i &lt; j\)</span>. This is to make the computation of the Ising cost function
more straightforward to write
using, for instance, standard numpy functions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For clarity and readability, we do not include any <strong>offset constant term</strong>
in the definitions above. A definition including this term would be:
<span class="math notranslate nohighlight">\(- \sum_{i=1}^{n} h_{i}s_{i} - \sum_{i,j=1}^{n} J_{ij}s_{i}s_{j} + o\)</span>,
with <span class="math notranslate nohighlight">\(o\)</span> the offset. Such a term does not change the <strong>optimization landscape</strong>,
but might be needed if one wants to <strong>match values</strong> when <strong>converting Ising cost functions into
QUBO instances and vice versa</strong>. See below for more details: <a class="reference internal" href="#qubo-description"><span class="std std-ref">QUBO</span></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the context of Ising Hamiltonians, qubits are also called <strong>spins</strong>.</p>
</div>
<p>Quantum annealing machines are typically designed to try and reach the <strong>minimum energy state
of Ising Hamiltonians</strong>, also called <strong>ground state</strong>, relying on the <strong>Adiabatic Theorem</strong>.
See for instance <a class="bibtex reference internal" href="#albash2018adiabatic" id="id4">[AL18]</a> for a general reference on adiabatic quantum computation.</p>
<p><strong>Classical annealing codes</strong> like Simulated Annealing (SA) and Simulated Quantum Annealing (SQA) try and do the same thing: Given <span class="math notranslate nohighlight">\(h\)</span> and <span class="math notranslate nohighlight">\(J\)</span> as input, they will, starting from a random configuration, try to apply <strong>updates</strong>, as part of <strong>Markov chain over the configuration space</strong>, in order to look for <strong>low energy states</strong>, where “energy” is defined by the formulas above.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A coupling value <span class="math notranslate nohighlight">\(J &gt; 0\)</span> between two spins <span class="math notranslate nohighlight">\(\sigma_{i}\)</span> and
<span class="math notranslate nohighlight">\(\sigma_{j}\)</span> can sometimes be called, in our convention, a <strong>ferromagnetic coupling</strong>,
as the alignment of the two spins onto a same value will tend to <strong>lower the energy</strong> of the system
making it closer to its <strong>ground state</strong>.</p>
</div>
<p>In other words, <strong>quantum annealing machines</strong> and, consequently, <strong>classical annealing codes</strong> (SA and SQA) aim at tackling the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[\min_{s_{1}...s_{n}\in \{-1,1\}} \left(- \sum_{i=1}^{n} h_{i}s_{i} - \sum_{i,j=1}^{n} J_{ij}s_{i}s_{j}\right)\]</div>
<p>given <span class="math notranslate nohighlight">\(h\)</span> and <span class="math notranslate nohighlight">\(J\)</span> as input.</p>
<p>To produce such Ising-formulated problems, one can use the <a class="reference internal" href="qat-opt.html#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.Ising</span></code></a> class. It is also possible to translate it to <a class="reference internal" href="qat-opt.html#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.QUBO</span></code></a> via <a class="reference internal" href="qat-opt.html#qat.opt.Ising.to_qubo" title="qat.opt.Ising.to_qubo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_qubo()</span></code></a> or to <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">CombinatorialProblem</span></code></a> via <a class="reference internal" href="qat-opt.html#qat.opt.Ising.to_combinatorial_problem" title="qat.opt.Ising.to_combinatorial_problem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_combinatorial_problem()</span></code></a>.</p>
</div>
<div class="section" id="quadratic-unconstrained-binary-optimization-qubo">
<span id="qubo-description"></span><h3>Quadratic Unconstrained Binary Optimization (QUBO)<a class="headerlink" href="#quadratic-unconstrained-binary-optimization-qubo" title="Permalink to this headline">¶</a></h3>
<p>Quadratic Unconstrained Binary Optimization consists in, given a <strong>real symmetric matrix</strong>
<span class="math notranslate nohighlight">\(Q\)</span>, <strong>minimizing</strong> the following cost function <span class="math notranslate nohighlight">\(q\)</span>:</p>
<div class="math notranslate nohighlight">
\[q(x_{1},...,x_{n}) = \sum_{i,j=1}^{n} Q_{ij}x_{i}x_{j}\]</div>
<p>where <span class="math notranslate nohighlight">\(x_{1},...,x_{n}\in \{0,1\}\)</span> are <strong>binary variables</strong>.</p>
<p>Written differently, by <strong>solving a QUBO problem</strong>, we mean solving,
given <span class="math notranslate nohighlight">\(Q\)</span>:</p>
<div class="math notranslate nohighlight">
\[\min_{x_{1}...x_{n}\in \{0,1\}} \sum_{i,j=1}^{n} Q_{ij}x_{i}x_{j}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <strong>diagonal</strong> of <span class="math notranslate nohighlight">\(Q\)</span> is allowed to contain <strong>non-zero elements</strong>.
Because <span class="math notranslate nohighlight">\(\forall i \quad x_{i}\in\{0,1\}\)</span>, <span class="math notranslate nohighlight">\(x_{i}^{2} = x_{i}\)</span>,
and the diagonal terms in the sum above effectively correspond to a <strong>linear part</strong>
of the cost function, which can be seen as similar to the <strong>magnetic field terms</strong>
in <strong>Ising Hamiltonians</strong>.</p>
</div>
<p><strong>QUBO instances</strong> are in one-to-one correspondance with <strong>Ising Hamiltonians and cost functions</strong>.</p>
<p>Indeed, starting from the expression above for <span class="math notranslate nohighlight">\(q\)</span>, the <strong>QUBO cost function</strong>,
and defining <span class="math notranslate nohighlight">\(s_{i}=2x_{i}-1\)</span> (<span class="math notranslate nohighlight">\(\in \{-1,1\}\)</span> as <span class="math notranslate nohighlight">\(x_{i}\in\{0,1\}\)</span>),
i.e <span class="math notranslate nohighlight">\(x_{i}=\frac{s_{i}+1}{2}\)</span>,
one can indeed write:</p>
<div class="math notranslate nohighlight">
\[\begin{split}q(x_{1},...x_{n}) &amp;= \sum_{i,j=1}^{n} Q_{i,j} x_{i}x_{j} \\~\\
                  &amp;= \sum_{i,j=1}^{n} Q_{i,j} \left(\frac{s_{i}+1}{2}\right)\left(\frac{s_{j}+1}{2}\right) \\~\\
                  &amp;= \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4}\left(1+s_{i}+s_{j}+s_{i}s_{j}\right) \\~\\
                  &amp;= \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4} + \sum_{i}\left(\sum_{j}\frac{Q_{i,j}}{4}\right) s_{i} + \sum_{j}\left(\sum_{i}\frac{Q_{i,j}}{4}\right) s_{j} + \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4} s_{i}s_{j} \\~\\
                  &amp;= \sum_{i,j=1}^{n} \frac{Q_{i,j}}{4} + \sum_{i=1}^{n} \frac{Q_{i,i}}{4} + \sum_{i}\left(\sum_{j}\frac{Q_{i,j}}{2}\right) s_{i}  + \sum_{i,j | i\neq j}^{n} \frac{Q_{i,j}}{4} s_{i}s_{j} \\~\\
                  &amp;= - \sum_{i=1}^{n} h_{i}s_{i} - \sum_{i,j=1}^{n} J_{ij}s_{i}s_{j} + o\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(h_{i}=-\sum_{j}\frac{Q_{i,j}}{2}\)</span>, <span class="math notranslate nohighlight">\(J_{ij}=-\frac{Q_{i,j}}{4}\)</span>
and an <strong>offset term</strong> <span class="math notranslate nohighlight">\(o=\sum_{i,j=1}^{n} \frac{Q_{i,j}}{4} + \sum_{i=1}^{n} \frac{Q_{i,i}}{4}\)</span>.</p>
<p>In this case, <a class="reference internal" href="qat-opt.html#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a> is the representative class and it can be translated to <a class="reference internal" href="qat-opt.html#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ising</span></code></a> and <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">CombinatorialProblem</span></code></a> via the <a class="reference internal" href="qat-opt.html#qat.opt.QUBO.to_ising" title="qat.opt.QUBO.to_ising"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_ising()</span></code></a> and <a class="reference internal" href="qat-opt.html#qat.opt.QUBO.to_combinatorial_problem" title="qat.opt.QUBO.to_combinatorial_problem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_combinatorial_problem()</span></code></a>, respectively.</p>
</div>
<div class="section" id="general-combinatorial-problems">
<span id="combinatorial-problem-description"></span><h3>General combinatorial problems<a class="headerlink" href="#general-combinatorial-problems" title="Permalink to this headline">¶</a></h3>
<p>The most general way to specify a combinatorial problem is by explicitly declaring boolean variables (<a class="reference internal" href="qat-opt.html#qat.opt.boolexpr.Var" title="qat.opt.boolexpr.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">Var</span></code></a>) and  clauses (<a class="reference internal" href="qat-opt.html#qat.opt.boolexpr.Clause" title="qat.opt.boolexpr.Clause"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clause</span></code></a>) combining these variables. This is achieved via the <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.opt.CombinatorialProblem</span></code></a> class.</p>
<p>While <a class="reference internal" href="#ising-description"><span class="std std-ref">Ising</span></a> and <a class="reference internal" href="#qubo-description"><span class="std std-ref">QUBO</span></a> only accept up to two-variable terms, one can define clauses in <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">CombinatorialProblem</span></code></a> with as many variables as desired. However, for the case of no more than two variables, a translation to the Ising and QUBO formulations is available using the <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem.to_ising" title="qat.opt.CombinatorialProblem.to_ising"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_ising()</span></code></a> and <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem.to_qubo" title="qat.opt.CombinatorialProblem.to_qubo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_qubo()</span></code></a> methods.</p>
<p>The cost Hamiltonian extraction is handled by the <a class="reference internal" href="qat-opt.html#qat.opt.boolexpr.Clause" title="qat.opt.boolexpr.Clause"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clause</span></code></a> class such that the final cost Hamiltonian constits of the weighted sum of the cost Hamiltonian of its clauses.</p>
</div>
</div>
<div class="section" id="solving-combinatorial-problems">
<span id="solving-comb"></span><h2>Solving combinatorial problems<a class="headerlink" href="#solving-combinatorial-problems" title="Permalink to this headline">¶</a></h2>
<div class="section" id="quantum-approximate-optimization-algorithm-qaoa">
<span id="qaoa-description"></span><h3>Quantum Approximate Optimization Algorithm (QAOA)<a class="headerlink" href="#quantum-approximate-optimization-algorithm-qaoa" title="Permalink to this headline">¶</a></h3>
<p>The Quantum Approximate Optimization Algorithm is a heuristic to design variational Ansätze for combinatorial optimization. It is inspired from the digitalization of an analog evolution using a linear ramp, starting from a simple initial Hamiltonian <span class="math notranslate nohighlight">\(H_0 = - \sum_i \sigma_x^i\)</span> to a diagonal Hamiltonian whose ground state encodes the solution to our problem.</p>
<p>The circuits produced by this method have shape:</p>
<div class="figure align-default">
<img alt="images/qaoa_circuit.PNG" src="images/qaoa_circuit.PNG" />
</div>
<p>where <span class="math notranslate nohighlight">\(H_0 = - \sum_i \sigma_x^i\)</span>, and <span class="math notranslate nohighlight">\(H_C\)</span> is an (efficiently generated) classical cost Hamiltonian that encodes the cost function to optimize. The propagator <span class="math notranslate nohighlight">\(e^{i\gamma H_C}\)</span> is usually simple to implement from a problem specification. <span class="math notranslate nohighlight">\(e^{i\beta H_0}\)</span> simply corresponds to a collection of <span class="math notranslate nohighlight">\(R_X\)</span> rotations of angle <span class="math notranslate nohighlight">\(2\beta\)</span>.</p>
<p>Once such a circuit is produced, one can use a QPU to minimize and a classical optimizer to minimize the quantity:
<span class="math notranslate nohighlight">\(\langle 0|C(\gamma, \beta)^\dagger H_C C(\gamma, \beta)|0 \rangle\)</span>
in order to produce a quantum state with the lowest possible energy (i.e that overlaps well the proper ground state of <span class="math notranslate nohighlight">\(H_C\)</span>, which, by construction, corresponds to the optimal solution of our problem). This can be handled via a variational plugin in the QLM, see <a class="reference internal" href="variational-plugin.html#variational-programs"><span class="std std-ref">this section</span></a> for more details.</p>
<p>As you can see, the circuit is also parametrized by a depth <span class="math notranslate nohighlight">\(d\)</span> corresponding to the number of alternating variational layers. The larger the depth, the better the approximation of the solution (at least in theory). In practice, increasing this parameter yields a larger circuit with greater number of parameters to optimize, which can slow down the convergence of the algorithm.</p>
<p>The algorithm is fully described in <a class="bibtex reference internal" href="#farhi2014quantum" id="id5">[FGG14]</a>.</p>
<p>It is possible to directly generate ready to run QAOA jobs (containing an Ansatz and the target Hamiltonian) from an instance of <a class="reference internal" href="qat-opt.html#qat.opt.CombinatorialProblem" title="qat.opt.CombinatorialProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">CombinatorialProblem</span></code></a>/<a class="reference internal" href="qat-opt.html#qat.opt.QUBO" title="qat.opt.QUBO"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUBO</span></code></a>/<a class="reference internal" href="qat-opt.html#qat.opt.Ising" title="qat.opt.Ising"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ising</span></code></a> via the <a class="reference internal" href="qat-opt.html#qat.opt.circuit_generator.CircuitGenerator" title="qat.opt.circuit_generator.CircuitGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">CircuitGenerator</span></code></a> class. In that case the qlm will take care of generating a cost Hamiltonian for the problem (depending on how you specified it).</p>
<p>If you need a lower level interface, the <a class="reference internal" href="qat-opt.html#qat.vsolve.ansatz.AnsatzFactory" title="qat.vsolve.ansatz.AnsatzFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.vsolve.ansatz.AnsatzFactory</span></code></a> provides a recipe to produce such a variational circuit from a target Hamiltonian. In both cases, the Ansatz factory allows you to pick between (at least) three different circuit synthesis strategies, yielding functionally equivalent circuits with different shapes.</p>
</div>
</div>
<div class="section" id="bibliography">
<h2>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h2>
<p id="bibtex-bibliography-combinatorial_optimization_intro-0"><dl class="citation">
<dt class="bibtex label" id="albash2018adiabatic"><span class="brackets"><a class="fn-backref" href="#id4">AL18</a></span></dt>
<dd><p>Tameem Albash and Daniel A Lidar. Adiabatic quantum computation. <em>Reviews of Modern Physics</em>, 90(1):015002, 2018. URL: <a class="reference external" href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.90.015002">https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.90.015002</a>.</p>
</dd>
<dt class="bibtex label" id="andriyash2017can"><span class="brackets"><a class="fn-backref" href="#id9">AA17</a></span></dt>
<dd><p>Evgeny Andriyash and Mohammad H Amin. Can quantum monte carlo simulate quantum annealing? 2017. <a class="reference external" href="https://arxiv.org/abs/1703.09277">arXiv:1703.09277</a>.</p>
</dd>
<dt class="bibtex label" id="denchev2016computational"><span class="brackets"><a class="fn-backref" href="#id7">DBI+16</a></span></dt>
<dd><p>Vasil S Denchev, Sergio Boixo, Sergei V Isakov, Nan Ding, Ryan Babbush, Vadim Smelyanskiy, John Martinis, and Hartmut Neven. What is the computational value of finite-range tunneling? <em>Physical Review X</em>, 6(3):031015, 2016. URL: <a class="reference external" href="https://journals.aps.org/prx/abstract/10.1103/PhysRevX.6.031015">https://journals.aps.org/prx/abstract/10.1103/PhysRevX.6.031015</a>.</p>
</dd>
<dt class="bibtex label" id="farhi2014quantum"><span class="brackets"><a class="fn-backref" href="#id5">FGG14</a></span></dt>
<dd><p>Edward Farhi, Jeffrey Goldstone, and Sam Gutmann. A quantum approximate optimization algorithm. 2014. <a class="reference external" href="https://arxiv.org/abs/1411.4028">arXiv:1411.4028</a>.</p>
</dd>
<dt class="bibtex label" id="hen2015probing"><span class="brackets"><a class="fn-backref" href="#id8">HJA+15</a></span></dt>
<dd><p>Itay Hen, Joshua Job, Tameem Albash, Troels F Rønnow, Matthias Troyer, and Daniel A Lidar. Probing for quantum speedup in spin-glass problems with planted solutions. <em>Physical Review A</em>, 92(4):042325, 2015. URL: <a class="reference external" href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.92.042325">https://journals.aps.org/pra/abstract/10.1103/PhysRevA.92.042325</a>.</p>
</dd>
<dt class="bibtex label" id="lucas2014ising"><span class="brackets">Luc14</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id3">2</a>)</span></dt>
<dd><p>Andrew Lucas. Ising formulations of many np problems. <em>Frontiers in Physics</em>, 2:5, 2014. URL: <a class="reference external" href="https://www.frontiersin.org/articles/10.3389/fphy.2014.00005/full">https://www.frontiersin.org/articles/10.3389/fphy.2014.00005/full</a>.</p>
</dd>
<dt class="bibtex label" id="martovnak2002quantum"><span class="brackets"><a class="fn-backref" href="#id10">MartovnakST02</a></span></dt>
<dd><p>Roman Martoňák, Giuseppe E Santoro, and Erio Tosatti. Quantum annealing by the path-integral monte carlo method: the two-dimensional random ising model. <em>Physical Review B</em>, 66(9):094203, 2002. URL: <a class="reference external" href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.66.094203">https://journals.aps.org/prb/abstract/10.1103/PhysRevB.66.094203</a>.</p>
</dd>
<dt class="bibtex label" id="ronnow2014defining"><span class="brackets"><a class="fn-backref" href="#id6">RonnowWJ+14</a></span></dt>
<dd><p>Troels F Rønnow, Zhihui Wang, Joshua Job, Sergio Boixo, Sergei V Isakov, David Wecker, John M Martinis, Daniel A Lidar, and Matthias Troyer. Defining and detecting quantum speedup. <em>science</em>, 345(6195):420–424, 2014. URL: <a class="reference external" href="https://science.sciencemag.org/content/345/6195/420.full">https://science.sciencemag.org/content/345/6195/420.full</a>.</p>
</dd>
</dl>
</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="myqlm_specific/interoperability.html" class="btn btn-neutral float-right" title="Interoperability with myQLM" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="running_variational.html" class="btn btn-neutral float-left" title="Running variational algorithms" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Atos 2016-2020

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>