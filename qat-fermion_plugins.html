<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Plugins &mdash; myQLM documentation  documentation</title>
      <link rel="stylesheet" href="static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="static/contentui.css" type="text/css" />
      <link rel="stylesheet" href="static/design-style.4045f2051d55cab465a707391d5b2007.min.css" type="text/css" />
    <link rel="shortcut icon" href="static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="static/documentation_options.js"></script>
        <script src="static/jquery.js"></script>
        <script src="static/underscore.js"></script>
        <script src="static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="static/doctools.js"></script>
        <script src="static/sphinx_highlight.js"></script>
        <script src="static/contentui.js"></script>
        <script src="static/design-tabs.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Changelog" href="qat-fermion_compatibility_guide.html" />
    <link rel="prev" title="Advanced usage" href="qat-fermion_advanced.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> myQLM documentation
            <img src="static/myqlm.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                myQLM-1.7.1-1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/install.html">Installing myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="programming.html">Writing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulating.html">Executing quantum circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="running_variational.html">Running variational algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="combinatorial_optimization_intro.html">Combinatorial optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/interoperability.html">Interoperability with myQLM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="notebooks.html">List of notebooks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Main objects: Jobs, Observables, Circuits…</a></li>
<li class="toctree-l1"><a class="reference internal" href="manipulating.html">Building custom execution stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="batch_generators.html">Building advanced computation stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_programming.html">Advanced programming using pyAQASM</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_combinatorial_optimization.html">Advanced combinatorial optimization</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="qat-fermion.html">Digital quantum simulation for spin and fermionic systems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="qat-fermion_basic.html">Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="qat-fermion_advanced.html">Advanced usage</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="qat-fermion_compatibility_guide.html">Changelog</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="aqasm.html">The AQASM format</a></li>
<li class="toctree-l1"><a class="reference internal" href="commands.html">Command-line tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Source code documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="source_doc.html">Source code documentation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/support.html">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/notebooks.html">Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/contrib.html">Contributing to myQLM</a></li>
<li class="toctree-l1"><a class="reference internal" href="myqlm_specific/release-note.html">Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">myQLM documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="qat-fermion.html">Digital quantum simulation for spin and fermionic systems</a> &raquo;</li>
      <li>Plugins</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="plugins">
<span id="qat-fermion-plugins"></span><h1>Plugins<a class="headerlink" href="#plugins" title="Permalink to this heading"></a></h1>
<p><a class="reference internal" href="qat-fermion.html#module-qat.fermion" title="qat.fermion"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.fermion</span></code></a> contains several plugins:</p>
<div class="sd-tab-set docutils">
<input checked="checked" id="sd-tab-item-0" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" data-sync-id="qat-fermion_plugins_adaptvqe" for="sd-tab-item-0">
ADAPT-VQE</label><div class="sd-tab-content docutils">
<p id="qat-fermion-plugins-adaptvqe"><a class="reference internal" href="qat-fermion.html#module-qat.fermion" title="qat.fermion"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qat.fermion</span></code></a> features an ADAPT-VQE plugin, called <a class="reference internal" href="plugin_adaptvqe.html#qat.plugins.AdaptVQEPlugin" title="qat.plugins.AdaptVQEPlugin"><code class="xref py py-class docutils literal notranslate"><span class="pre">AdaptVQEPlugin</span></code></a>. Its purpose is to build ansatze for
VQE by selecting automatically operators in a given pool. This selection is done by computing a commutator between said operator and
the observable, which is a way to determine which operator would have the most influence on the resulting energy.
While this selection can be slower than directly building other standard ansatze, ADAPT-VQE builds automatically efficient ansatze,
and can lead to improved overall VQE performance.</p>
<p>Let us see how to initialize and use <a class="reference internal" href="plugin_adaptvqe.html#qat.plugins.AdaptVQEPlugin" title="qat.plugins.AdaptVQEPlugin"><code class="xref py py-class docutils literal notranslate"><span class="pre">AdaptVQEPlugin</span></code></a>. We are interested in computing the ground state of
molecule.
For the sake of simplicity, we will assume we have already the variable <code class="code docutils literal notranslate"><span class="pre">cluster_operators</span></code>, containing a list of
<a class="reference internal" href="qat-core.html#qat.core.Observable" title="qat.core.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Observable</span></code></a>, and <code class="code docutils literal notranslate"><span class="pre">hamiltonian</span></code>, the <a class="reference internal" href="qat-fermion_source.html#qat.fermion.hamiltonians.SpinHamiltonian" title="qat.fermion.hamiltonians.SpinHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinHamiltonian</span></code></a> object containing the
Hamiltonian of our system. We also assume we have computed the correct initial Harree-Fock state in binary
representation, represented by the variable <code class="code docutils literal notranslate"><span class="pre">hf_init</span></code>. These steps can be seen in more details in our two tutorials
<a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fdigital_quantum_simulations_spin_fermion%2Fqat_fermion_vqe_ucc_example_1_h2.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">VQE for a H2 molecule using the UCC ansatz</a> and
<a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fdigital_quantum_simulations_spin_fermion%2Fqat_fermion_vqe_ucc_example_2_lih.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">VQE for a LiH molecule using the UCC ansatz</a>.</p>
<p>We first need to initialize the circuit with a Hartree-Fock state, and generate a variational <a class="reference internal" href="qat-core.html#qat.core.Job" title="qat.core.Job"><code class="xref py py-class docutils literal notranslate"><span class="pre">Job</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.plugins</span> <span class="kn">import</span> <span class="n">AdaptVQEPlugin</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span><span class="p">,</span> <span class="n">X</span>

<span class="c1"># Initialize a Program</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">reg</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">nbqbits</span><span class="p">)</span>

<span class="c1"># Define the circuit which prepares a Hartree-Fock state</span>
<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">hf_init</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">nbqbits</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;b&quot;</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">reg</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

<span class="c1"># Generate the associated circuit</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>

<span class="c1"># Define the variational Job we need to optimize</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">to_job</span><span class="p">(</span><span class="n">observable</span><span class="o">=</span><span class="n">hamiltonian</span><span class="p">)</span>
</pre></div>
</div>
<p>We now need to define the stack for the computation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.plugins</span> <span class="kn">import</span> <span class="n">AdaptVQEPlugin</span><span class="p">,</span> <span class="n">ScipyMinimizePlugin</span>

<span class="c1"># Define the stack</span>
<span class="n">adaptvqe_plugin</span> <span class="o">=</span> <span class="n">AdaptVQEPlugin</span><span class="p">(</span><span class="n">cluster_operators</span><span class="p">,</span> <span class="n">n_iterations</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">ScipyMinimizePlugin</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;COBYLA&quot;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">},</span> <span class="n">x0</span><span class="o">=</span><span class="n">theta_init</span><span class="p">)</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span>

<span class="n">stack</span> <span class="o">=</span> <span class="n">adaptvqe_plugin</span> <span class="o">|</span> <span class="n">optimizer</span> <span class="o">|</span> <span class="n">qpu</span>
</pre></div>
</div>
<p>Everything is set up ! The <a class="reference internal" href="plugin_adaptvqe.html#qat.plugins.AdaptVQEPlugin" title="qat.plugins.AdaptVQEPlugin"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.plugins.AdaptVQEPlugin</span></code></a> will generate the variational ansatz to be optimized by
<a class="reference internal" href="variational-plugin.html#qat.plugins.ScipyMinimizePlugin" title="qat.plugins.ScipyMinimizePlugin"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.plugins.ScipyMinimizePlugin</span></code></a>, the latter doing back and forth with the QPU to optimize the ansatz parameters. Let’s
submit the job:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Submit the job</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>

<span class="c1"># Print the energy value</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computed energy = </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected energy = </span><span class="si">{</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Computed</span> <span class="n">energy</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.1372701679264894</span>
<span class="go">    Expected energy = -1.1372701679265027</span>
</pre></div>
</div>
</div>
<input id="sd-tab-item-1" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" data-sync-id="qat-fermion_plugins_natgrad" for="sd-tab-item-1">
Natural gradient-based optimizer</label><div class="sd-tab-content docutils">
<p id="qat-fermion-plugins-natgrad">Gradient descent optimizer (<a class="reference internal" href="plugin_gradient_descent.html#qat.plugins.GradientDescentOptimizer" title="qat.plugins.GradientDescentOptimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientDescentOptimizer</span></code></a>) represent a very standard class of optimizer. To minimize a given function, the gradient of
this function with respect to each of its parameters is computed. This allows the update of the parameters such that the final value
of the function decreases.</p>
<p>To minimize a function <span class="math notranslate nohighlight">\(L(\theta)\)</span>, we update <span class="math notranslate nohighlight">\(\theta\)</span> iteratively such that:</p>
<div class="math notranslate nohighlight">
\[\theta_{t+1} =\theta_{t} - \eta \nabla L(\theta_{t})\]</div>
<p><span class="math notranslate nohighlight">\(\eta\)</span> is the learning parameter.</p>
<p>Doing this iteratively, we get a set of parameters which minimize the given function. Many algorithms such as
the stochastic gradient descent algorithm (<strong>SGD</strong>) or its adaptative extension <strong>Adam</strong> work this way.</p>
<p>However, these optimizers assume the parameter space is Euclidean, meaning that during the parameters update, each parameter is
updated by the same Euclidean distance. This is a baseless assumption, and at best a good approximation, since the loss function
might change at different rates depending on the parameter considered.
To correct for this behaviour, we can use the <a class="reference external" href="https://en.wikipedia.org/wiki/Fisher_information">*Fisher information matrix*</a>,
which acts as a metric tensor by transforming the steepest descent in the parameter space to a steepest descent in the distribution
space.</p>
<p>The same issue arises when it comes to optimizing variational parameters of a quantum circuit. By using the Fubini-Study metric
tensor <span class="math notranslate nohighlight">\(g\)</span>, one can devise a quantum analog to the classical natural gradient descent defined earlier:</p>
<div class="math notranslate nohighlight">
\[\theta_{t+1} =\theta_{t} - \eta g^{+}(\theta_{t}) \nabla L(\theta_{t})\]</div>
<p>Here, <span class="math notranslate nohighlight">\(g^{+}\)</span> represents the pseudo-inverse of the Fubini-Study metric tensor <span class="math notranslate nohighlight">\(g\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For more information, see <a class="reference external" href="http://dx.doi.org/10.22331/q-2020-05-25-269">this publication</a>.</p>
</div>
<p>The quantum natural gradient descent algorithm is available in the QLM and can be accessed via the
<a class="reference internal" href="plugin_gradient_descent.html#qat.plugins.GradientDescentOptimizer" title="qat.plugins.GradientDescentOptimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientDescentOptimizer</span></code></a> plugin. It features both the standard and the natural gradient descent algorithm.</p>
<p>Let us use the natural gradient-based optimizer to solve a variational problem. We want to compute the expectation value of an
observable by VQE, using a custom ansatz.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qat.core</span> <span class="kn">import</span> <span class="n">Observable</span><span class="p">,</span> <span class="n">Term</span>
<span class="kn">from</span> <span class="nn">qat.lang.AQASM</span> <span class="kn">import</span> <span class="n">Program</span><span class="p">,</span> <span class="n">RX</span><span class="p">,</span> <span class="n">RY</span><span class="p">,</span> <span class="n">RZ</span><span class="p">,</span> <span class="n">CNOT</span>

<span class="n">nbqbits</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># Define the observable</span>
<span class="n">obs</span> <span class="o">=</span> <span class="n">Observable</span><span class="p">(</span><span class="n">nbqbits</span><span class="p">,</span> <span class="n">pauli_terms</span><span class="o">=</span><span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])])</span>

<span class="c1"># Build a parameterized circuit</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">Program</span><span class="p">()</span>
<span class="n">reg</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="n">nbqbits</span><span class="p">)</span>

<span class="n">RY</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">RZ</span><span class="p">(</span><span class="n">prog</span><span class="o">.</span><span class="n">new_var</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">theta_0&quot;</span><span class="p">))(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">RZ</span><span class="p">(</span><span class="n">prog</span><span class="o">.</span><span class="n">new_var</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">theta_1&quot;</span><span class="p">))(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">RZ</span><span class="p">(</span><span class="n">prog</span><span class="o">.</span><span class="n">new_var</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">theta_2&quot;</span><span class="p">))(</span><span class="n">reg</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">RY</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">RY</span><span class="p">(</span><span class="n">prog</span><span class="o">.</span><span class="n">new_var</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">theta_3&quot;</span><span class="p">))(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">RY</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)(</span><span class="n">reg</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">RY</span><span class="p">(</span><span class="n">prog</span><span class="o">.</span><span class="n">new_var</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">theta_4&quot;</span><span class="p">))(</span><span class="n">reg</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reg</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">to_circ</span><span class="p">()</span>
</pre></div>
</div>
<p>We initialize the plugin.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qat.qpus</span> <span class="kn">import</span> <span class="n">get_default_qpu</span>
<span class="kn">from</span> <span class="nn">qat.plugins</span> <span class="kn">import</span> <span class="n">GradientDescentOptimizer</span>

<span class="c1"># Initialize Optimizer</span>
<span class="n">natgrad_opt</span> <span class="o">=</span> <span class="n">GradientDescentOptimizer</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">learning_parameter</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">natural_gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>

<span class="c1"># Define which QPU to use</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">get_default_qpu</span><span class="p">()</span>

<span class="c1"># Define the stack</span>
<span class="n">stack</span> <span class="o">=</span> <span class="n">natgrad_opt</span> <span class="o">|</span> <span class="n">qpu</span>
</pre></div>
</div>
<p>The stack is defined ! Let us run the job on the QPU:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">to_job</span><span class="p">(</span><span class="n">job_type</span><span class="o">=</span><span class="s2">&quot;OBS&quot;</span><span class="p">,</span> <span class="n">observable</span><span class="o">=</span><span class="n">obs</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected value for the observable = </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Expected</span> <span class="n">value</span> <span class="k">for</span> <span class="n">the</span> <span class="n">observable</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.8660254037652464</span>
</pre></div>
</div>
<p>More information on how to use this plugin is available in the following Jupyter notebook: <a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fdigital_quantum_simulations_spin_fermion%2Fqat_fermion_natural_gradient_vqe.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">Natural gradient-based optimizer</a>.</p>
</div>
<input id="sd-tab-item-2" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" data-sync-id="qat-fermion_plugins_seqoptim" for="sd-tab-item-2">
Sequential optimizer</label><div class="sd-tab-content docutils">
<p id="qat-fermion-plugins-seqoptim">The sequential minimization optimization algorithm is a hybrid classical-quantum algorithm which leverages the parameter shift rule
to locally optimize the angles of a certain class of circuit with 3 energy measurements. The full algorithm is described in
<a class="reference external" href="https://arxiv.org/abs/1903.12166">an article by Nakanishi et al. (2020)</a> and also in
<a class="reference external" href="https://arXiv.org/abs/1905.09692">an article by Ostaszewski et al., (2021)</a>.</p>
<p>This algorithm only applies to circuits containing gates of the form <span class="math notranslate nohighlight">\(G(\theta)=e^{-ic\theta/2\hat{P}}\)</span>, with <span class="math notranslate nohighlight">\(\hat{P}\)</span>
a tensor product of Pauli matrices and <span class="math notranslate nohighlight">\(c\)</span> a constant coefficient.</p>
<p>The sequential optimization algorithm has been implemented as an plugin called <a class="reference internal" href="variational-plugin.html#qat.plugins.SeqOptim" title="qat.plugins.SeqOptim"><code class="xref py py-class docutils literal notranslate"><span class="pre">qat.plugins.SeqOptim</span></code></a>. For the class of
circuit previously, it usually outperforms more standard optimizers such as the methods implemented in the plugin
<a class="reference internal" href="variational-plugin.html#qat.plugins.ScipyMinimizePlugin" title="qat.plugins.ScipyMinimizePlugin"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScipyMinimizePlugin</span></code></a>, while having a low sensitivity to shot noise.</p>
<p>For more information, please refer to the notebook
<a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fdigital_quantum_simulations_spin_fermion%2Fqat_fermion_sequential_optimization_plugin.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">Optimizing circuits with the sequential optimization plugin</a>.</p>
</div>
<input id="sd-tab-item-3" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" data-sync-id="qat-fermion_plugins_zeronoise" for="sd-tab-item-3">
Zero-noise extrapolator</label><div class="sd-tab-content docutils">
<p id="qat-fermion-plugins-zeronoise">The plugin <a class="reference internal" href="plugin_zeronoise.html#qat.plugins.ZeroNoiseExtrapolator" title="qat.plugins.ZeroNoiseExtrapolator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZeroNoiseExtrapolator</span></code></a> is a plugin whch helps mitigate multiqubit gate noise by means of an
extrapolation to the zero noise regime. It is use in the following notebook : <a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fdigital_quantum_simulations_spin_fermion%2Fqat_fermion_zero_noise_extrapolation_plugin.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">Mitigating multiqubit noise (QLM users only)</a>.</p>
<p>The idea is to measure the observable of interest <span class="math notranslate nohighlight">\(\hat{O}\)</span> under varying noise intensities, so that a noise-free value can be
inferred. The noise is artificially increased by multiplying the number of <span class="math notranslate nohighlight">\(CNOT\)</span> gates: since <span class="math notranslate nohighlight">\(CNOT^2=I\)</span>, one can
replace each <span class="math notranslate nohighlight">\(CNOT\)</span> gate in the circuit by a number <span class="math notranslate nohighlight">\(2n_{\mathrm{pairs}}+1\)</span> of identical <span class="math notranslate nohighlight">\(CNOT\)</span> gates without
changing the logical function of the circuit. Since the two-qubit gates are considerably more faulty than the one-qubit gates, this
boils down to globally increasing the noise that will be picked at the execution of the circuit: one can show that as a first
approximation, considering the gate noise can be modelled by a depolarizing channel, the equivalent noise level will correspond to a
<span class="math notranslate nohighlight">\((2n_{\mathrm{pairs}}+1)\)</span>-fold increase of the original noise level
(see <a class="reference external" href="https://arxiv.org/abs/2011.01382">Hybrid quantum-classical algorithms and quantum error mitigation by endo et al. (2021)</a> p.23 for
the detailed calculation).</p>
<p>By choosing a fit <span class="math notranslate nohighlight">\(f\)</span> so that <span class="math notranslate nohighlight">\(\langle \hat{O} \rangle_{\mathrm{noisy}} = f(n_\mathrm{pairs})\)</span>, one can thus estimate the
noise-free expectation value of the observable as <span class="math notranslate nohighlight">\(\langle \hat{O} \rangle_{\mathrm{noise-free, inferred}}  = f(-0.5)\)</span>.</p>
<p>The plugin allows for either a linear fit (Richardson extrapolation):</p>
<div class="math notranslate nohighlight">
\[f(n_\mathrm{pairs}) = an_\mathrm{pairs} + b,\]</div>
<p>or an exponential one:</p>
<div class="math notranslate nohighlight">
\[f(n_\mathrm{pairs}) = \pm e^{an_\mathrm{pairs}+b} + C.\]</div>
<p><strong>Note</strong>: The plugin allows to increase the noise level with a gate that is different from the <span class="math notranslate nohighlight">\(CNOT\)</span> gate. This corresponds to the
more general “unitary-folding” technique, in which we replace each occurence of <span class="math notranslate nohighlight">\(G\)</span> by <span class="math notranslate nohighlight">\(G(GG^{\dagger})^n\)</span>. See for example
<a class="reference external" href="https://arxiv.org/abs/2005.10921">Digital zero noise extrapolation for quantum error mitigation by Giurgica-Tiron et al. (2020)</a>.</p>
</div>
<input id="sd-tab-item-4" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" data-sync-id="qat-fermion_plugins_multiplelaunches" for="sd-tab-item-4">
MultipleLaunchesAnalyzer</label><div class="sd-tab-content docutils">
<p id="qat-fermion-plugins-multiplelaunches">The plugin <a class="reference internal" href="plugin_multiplelaunches.html#qat.plugins.MultipleLaunchesAnalyzer" title="qat.plugins.MultipleLaunchesAnalyzer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultipleLaunchesAnalyzer</span></code></a> is a very simple plugin allowing the optimization of a variational process multiples times at once. This can be useful
when it is unclear which initial parameters to use for an ansatz or a set of ansatze, as the plugin computes several optimizations
with different set of random initial parameters, but also the variance of the results obtained.</p>
<p>For more information on how to use this plugin, refer to the notebook
<a href="https://mybinder.org/v2/gh/myQLM/myqlm-notebooks/HEAD?filepath=tutorials%2Fdigital_quantum_simulations_spin_fermion%2Fqat_fermion_multiple_launches_analyzer_plugin.ipynb" style="color: #ff7823; text-decoration: underline; cursor: pointer">Running several optimizations and keeping the best one with MultipleLaunchesAnalyzer</a>.</p>
</div>
</div>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="qat-fermion_advanced.html" class="btn btn-neutral float-left" title="Advanced usage" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="qat-fermion_compatibility_guide.html" class="btn btn-neutral float-right" title="Changelog" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Atos 2016-2022.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>